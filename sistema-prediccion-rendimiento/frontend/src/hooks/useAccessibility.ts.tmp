import { useCallback, useEffect, useState } from 'react';

// Constantes
const STORAGE_KEY = 'accessibility-settings';
const FORM_KEY = 'accessibility-form';

// Interfaces y tipos
export type AccessibilitySettings = {
  // Auditiva
  autoTranscription?: boolean;
  audioControls?: boolean;
  visualAlerts?: boolean;
  signLanguage?: boolean;

  // Visual
  textSize?: number; // 1..5
  fontType?: string;
  linkHighlight?: boolean;
  textSpacing?: number; // 1..5
  darkMode?: boolean;
  highContrast?: boolean;

  // Motriz
  keyboardNavigation?: boolean;
  largeButtons?: boolean;
  voiceControl?: boolean;
  autoScrollBlock?: boolean;
};

const DEFAULTS: AccessibilitySettings = {
  autoTranscription: false,
  audioControls: false,
  visualAlerts: false,
  signLanguage: false,
  textSize: 1,
  fontType: 'Arial',
  linkHighlight: false,
  textSpacing: 1,
  darkMode: false,
  highContrast: false,
  keyboardNavigation: true,
  largeButtons: false,
  voiceControl: false,
  autoScrollBlock: false,
};

type EventListenerInfo = {
  type: string;
  handler: EventListener;
  element: HTMLElement | Document;
};

function removeEventListeners(element: HTMLElement | Document, events: string[]): void {
  const eventListeners: EventListenerInfo[] = [];

  const addToList = (type: string, handler: EventListener, elem: HTMLElement | Document): void => {
    eventListeners.push({ type, handler, element: elem });
  };

  const removeFromList = (type: string, handler: EventListener): void => {
    const index = eventListeners.findIndex(l => l.type === type && l.handler === handler);
    if (index > -1) {
      eventListeners.splice(index, 1);
    }
  };

  const originalAddEventListener = element.addEventListener.bind(element);
  const originalRemoveEventListener = element.removeEventListener.bind(element);

  element.addEventListener = function(
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void {
    addToList(type, handler as EventListener, element);
    originalAddEventListener(type, handler, options);
  };

  element.removeEventListener = function(
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void {
    removeFromList(type, handler as EventListener);
    originalRemoveEventListener(type, handler, options);
  };

  events.forEach(event => {
    const listenersToRemove = eventListeners.filter(l => l.type === event && l.element === element);
    listenersToRemove.forEach(l => {
      l.element.removeEventListener(l.type, l.handler);
    });
  });
}

function applySettingsToDOM(s: AccessibilitySettings): void {
  try {
    const docEl = document.documentElement;
    const body = document.body;

    // Remover clases y propiedades existentes
    const classesToRemove = [
      'accessibility-enabled',
      'highlight-links',
      'keyboard-nav',
      'large-buttons',
      'auto-scroll-block',
      'high-contrast',
      'dark-mode'
    ];
    body.classList.remove(...classesToRemove);

    const propertiesToReset = [
      'font-family',
      '--text-size-scale',
      '--text-letter-spacing',
      '--text-line-height',
      'scroll-behavior'
    ];
    propertiesToReset.forEach(prop => {
      body.style.removeProperty(prop);
      docEl.style.removeProperty(prop);
    });

    // Verificar si hay configuraciones activas
    const hasActiveSettings = Object.entries(s).some(([key, value]) => {
      if (key === 'textSize' || key === 'textSpacing') return value !== 1;
      if (key === 'fontType') return value !== 'Arial';
      return Boolean(value);
    });

    if (hasActiveSettings) {
      body.classList.add('accessibility-enabled');
    }

    // Modo oscuro y alto contraste
    if (s.darkMode) {
      body.classList.add('dark-mode');
      docEl.setAttribute('data-theme', 'dark');
    } else {
      docEl.setAttribute('data-theme', 'light');
    }

    if (s.highContrast) {
      body.classList.add('high-contrast');
    }

    // Tamaño y espaciado de texto
    if (s.textSize && s.textSize !== 1) {
      const textSizeScale = 1 + (Math.max(1, Math.min(5, s.textSize)) - 1) * 0.2;
      docEl.style.setProperty('--text-size-scale', String(textSizeScale));
    }

    if (s.fontType && s.fontType !== 'Arial') {
      body.style.setProperty('font-family', `${s.fontType}, system-ui, sans-serif`);
    }

    if (s.textSpacing && s.textSpacing > 1) {
      const spacing = Math.max(1, Math.min(5, s.textSpacing));
      const letterSpacing = (spacing - 1) * 0.05;
      const lineHeight = 1.5 + (spacing - 1) * 0.25;
      body.style.setProperty('--text-letter-spacing', `${letterSpacing}em`);
      body.style.setProperty('--text-line-height', String(lineHeight));
    }

    // Enlaces resaltados
    if (s.linkHighlight) {
      body.classList.add('highlight-links');
      document.querySelectorAll('a').forEach(link => {
        if (!link.classList.contains('no-highlight')) {
          link.setAttribute('data-highlighted', 'true');
        }
      });
    } else {
      body.classList.remove('highlight-links');
      document.querySelectorAll('a[data-highlighted]').forEach(link => {
        link.removeAttribute('data-highlighted');
      });
    }

    // Navegación por teclado
    const keyboardNavStyleId = 'keyboard-nav-style';
    if (s.keyboardNavigation) {
      body.classList.add('keyboard-nav');
      if (!document.getElementById(keyboardNavStyleId)) {
        const style = document.createElement('style');
        style.id = keyboardNavStyleId;
        style.textContent = `
          .keyboard-nav *:focus {
            outline: 3px solid #2563eb !important;
            outline-offset: 2px !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3) !important;
          }
        `;
        document.head.appendChild(style);
      }
    } else {
      body.classList.remove('keyboard-nav');
      document.getElementById(keyboardNavStyleId)?.remove();
    }

    // Botones grandes
    if (s.largeButtons) {
      body.classList.add('large-buttons');
      document.querySelectorAll('button, .btn, input[type="button"], input[type="submit"]')
        .forEach(button => {
          if (button instanceof HTMLElement) {
            button.setAttribute('data-original-size', 'true');
          }
        });
    } else {
      body.classList.remove('large-buttons');
      document.querySelectorAll('[data-original-size]')
        .forEach(button => button.removeAttribute('data-original-size'));
    }

    // Control de scroll y animaciones
    if (s.autoScrollBlock) {
      body.classList.add('auto-scroll-block');
      docEl.style.scrollBehavior = 'auto';
      document.getAnimations().forEach(animation => {
        if (!animation.finished) {
          animation.pause();
          animation.currentTime = 0;
        }
      });
    } else {
      body.classList.remove('auto-scroll-block');
      docEl.style.removeProperty('scroll-behavior');
      document.getAnimations().forEach(animation => {
        if (animation.playState === 'paused') animation.play();
      });
    }

    // Control de audio y transcripciones
    document.querySelectorAll('video, audio').forEach(media => {
      const elem = media as HTMLMediaElement;
      elem.controls = s.audioControls || false;
      
      Array.from(elem.textTracks).forEach(track => {
        if (track.kind === 'subtitles' || track.kind === 'captions') {
          track.mode = s.autoTranscription ? 'showing' : 'disabled';
        }
      });
    });

    // Alertas visuales
    if (s.visualAlerts) {
      document.querySelectorAll('audio').forEach(audio => {
        if (!audio.hasAttribute('data-visual-alert-handler')) {
          const handlePlay = () => {
            const alert = document.createElement('div');
            alert.className = 'audio-visual-alert';
            alert.setAttribute('role', 'status');
            alert.setAttribute('aria-live', 'polite');
            document.body.appendChild(alert);
            setTimeout(() => alert.remove(), 2000);
          };
          audio.addEventListener('play', handlePlay);
          audio.setAttribute('data-visual-alert-handler', 'true');
        }
      });
    } else {
      document.querySelectorAll('audio[data-visual-alert-handler]').forEach(audio => {
        if (audio instanceof HTMLAudioElement) {
          removeEventListeners(audio, ['play']);
          audio.removeAttribute('data-visual-alert-handler');
        }
      });
    }

    // Control por voz
    if (s.voiceControl && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      body.setAttribute('data-voice-control', 'true');
    } else {
      body.removeAttribute('data-voice-control');
    }

  } catch (error) {
    console.warn('Error applying accessibility settings:', error);
  }
}

// Hook principal
export function useAccessibility() {
  const [settings, setSettings] = useState<AccessibilitySettings>(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : DEFAULTS;
    } catch {
      return DEFAULTS;
    }
  });

  // Aplicar configuraciones y guardar
  useEffect(() => {
    applySettingsToDOM(settings);
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    } catch (error) {
      console.warn('Error saving accessibility settings:', error);
    }
  }, [settings]);

  // Sincronización entre pestañas
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (!e.key) return;

      if (e.key === FORM_KEY) {
        try {
          const form = e.newValue ? JSON.parse(e.newValue) : null;
          if (!form) return;
          
          setSettings(prev => {
            const next = { ...prev };
            const visualKeys: Array<keyof AccessibilitySettings> = [
              'darkMode',
              'highContrast',
              'textSize',
              'fontType',
              'linkHighlight',
              'textSpacing'
            ];
            visualKeys.forEach(k => {
              if (form[k] !== undefined) next[k] = form[k];
            });
            return next;
          });
        } catch {
          // Ignorar errores de parsing
        }
      } else if (e.key === STORAGE_KEY && e.newValue) {
        try {
          const newSettings = JSON.parse(e.newValue);
          setSettings(newSettings);
          applySettingsToDOM(newSettings);
        } catch (error) {
          console.warn('Error syncing accessibility settings:', error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);

  // Actualizar configuración individual
  const updateSetting = useCallback(<K extends keyof AccessibilitySettings>(
    key: K,
    value: AccessibilitySettings[K]
  ): void => {
    setSettings(prev => ({ ...prev, [key]: value }));
  }, []);

  // Restablecer configuraciones
  const resetSettings = useCallback((): void => {
    setSettings(DEFAULTS);
  }, []);

  return {
    settings,
    updateSetting,
    resetSettings
  };
}