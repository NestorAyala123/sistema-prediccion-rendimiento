import { useCallback, useEffect, useState } from 'react';

// Constantes
const STORAGE_KEY = 'accessibility-settings';
const FORM_KEY = 'accessibility-form';

// Interfaces y tipos
export type AccessibilitySettings = {
  // Auditiva
  autoTranscription?: boolean;
  audioControls?: boolean;
  visualAlerts?: boolean;
  signLanguage?: boolean;

  // Visual
  textSize?: number; // 1..5
  fontType?: string;
  linkHighlight?: boolean;
  textSpacing?: number; // 1..5
  darkMode?: boolean;
  highContrast?: boolean;

  // Motriz
  keyboardNavigation?: boolean;
  largeButtons?: boolean;
  voiceControl?: boolean;
  autoScrollBlock?: boolean;
};

const DEFAULTS: AccessibilitySettings = {
  autoTranscription: false,
  audioControls: false,
  visualAlerts: false,
  signLanguage: false,
  textSize: 1,
  fontType: 'Arial',
  linkHighlight: false,
  textSpacing: 1,
  darkMode: false,
  highContrast: false,
  keyboardNavigation: true,
  largeButtons: false,
  voiceControl: false,
  autoScrollBlock: false,
};

type EventListenerInfo = {
  type: string;
  handler: EventListener;
  element: HTMLElement | Document;
};

// Funciones auxiliares
function removeEventListeners(element: HTMLElement | Document, events: string[]): void {
  const eventListeners: EventListenerInfo[] = [];

  const addToList = (type: string, handler: EventListener, elem: HTMLElement | Document): void => {
    eventListeners.push({ type, handler, element: elem });
  };

  const removeFromList = (type: string, handler: EventListener): void => {
    const index = eventListeners.findIndex(l => l.type === type && l.handler === handler);
    if (index > -1) {
      eventListeners.splice(index, 1);
    }
  };

  const originalAddEventListener = element.addEventListener.bind(element);
  const originalRemoveEventListener = element.removeEventListener.bind(element);

  element.addEventListener = function(
    this: HTMLElement | Document,
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void {
    addToList(type, handler as EventListener, this);
    originalAddEventListener(type, handler, options);
  };

  element.removeEventListener = function(
    this: HTMLElement | Document,
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void {
    removeFromList(type, handler as EventListener);
    originalRemoveEventListener(type, handler, options);
  };

  events.forEach(event => {
    const listenersToRemove = eventListeners.filter(l => l.type === event && l.element === element);
    listenersToRemove.forEach(l => {
      l.element.removeEventListener(l.type, l.handler);
    });
  });
}

function applySettingsToDOM(s: AccessibilitySettings): void {
  try {
    const docEl = document.documentElement;
    const body = document.body;

    // Remover clases y propiedades existentes
    const classesToRemove = [
      'accessibility-enabled',
      'highlight-links',
      'keyboard-nav',
      'large-buttons',
      'auto-scroll-block'
    ];
    body.classList.remove(...classesToRemove);

    const propertiesToReset = [
      'font-family',
      '--text-size-scale',
      '--text-letter-spacing',
      '--text-line-height',
      'scroll-behavior'
    ];
    propertiesToReset.forEach(prop => {
      body.style.removeProperty(prop);
      docEl.style.removeProperty(prop);
    });

    // Verificar si hay configuraciones activas
    const hasActiveSettings = Object.entries(s).some(([key, value]) => {
      if (key === 'textSize' || key === 'textSpacing') return value !== 1;
      if (key === 'fontType') return value !== 'Arial';
      return Boolean(value);
    });

    if (hasActiveSettings) {
      body.classList.add('accessibility-enabled');
    }

    // Aplicar configuraciones
    if (s.textSize && s.textSize !== 1) {
      const textSizeScale = 1 + (Math.max(1, Math.min(5, s.textSize)) - 1) * 0.2;
      docEl.style.setProperty('--text-size-scale', String(textSizeScale));
    }

    if (s.fontType && s.fontType !== 'Arial') {
      body.style.setProperty('font-family', `${s.fontType}, system-ui, sans-serif`);
    }

    if (s.textSpacing && s.textSpacing > 1) {
      const spacing = Math.max(1, Math.min(5, s.textSpacing));
      const letterSpacing = (spacing - 1) * 0.05;
      const lineHeight = 1.5 + (spacing - 1) * 0.25;
      body.style.setProperty('--text-letter-spacing', `${letterSpacing}em`);
      body.style.setProperty('--text-line-height', String(lineHeight));
    }

    // Enlaces resaltados
    if (s.linkHighlight) {
      body.classList.add('highlight-links');
      document.querySelectorAll('a').forEach(link => {
        if (!link.classList.contains('no-highlight')) {
          link.setAttribute('data-highlighted', 'true');
        }
      });
    } else {
      body.classList.remove('highlight-links');
      document.querySelectorAll('a[data-highlighted]').forEach(link => {
        link.removeAttribute('data-highlighted');
      });
    }

    // Navegación por teclado
    const keyboardNavStyleId = 'keyboard-nav-style';
    if (s.keyboardNavigation) {
      body.classList.add('keyboard-nav');
      if (!document.getElementById(keyboardNavStyleId)) {
        const style = document.createElement('style');
        style.id = keyboardNavStyleId;
        style.textContent = `
          .keyboard-nav *:focus {
            outline: 3px solid #2563eb !important;
            outline-offset: 2px !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3) !important;
          }
        `;
        document.head.appendChild(style);
      }
    } else {
      body.classList.remove('keyboard-nav');
      document.getElementById(keyboardNavStyleId)?.remove();
    }

    // Botones grandes
    if (s.largeButtons) {
      body.classList.add('large-buttons');
      document.querySelectorAll('button, .btn, input[type="button"], input[type="submit"]')
        .forEach(button => {
          if (button instanceof HTMLElement) {
            button.setAttribute('data-original-size', 'true');
          }
        });
    } else {
      body.classList.remove('large-buttons');
      document.querySelectorAll('[data-original-size]')
        .forEach(button => button.removeAttribute('data-original-size'));
    }

    // Control de scroll y animaciones
    if (s.autoScrollBlock) {
      body.classList.add('auto-scroll-block');
      docEl.style.scrollBehavior = 'auto';
      document.getAnimations().forEach(animation => {
        if (!animation.finished) {
          animation.pause();
          animation.currentTime = 0;
        }
      });
    } else {
      body.classList.remove('auto-scroll-block');
      docEl.style.removeProperty('scroll-behavior');
      document.getAnimations().forEach(animation => {
        if (animation.playState === 'paused') animation.play();
      });
    }

    // Control de audio y transcripciones
    document.querySelectorAll('video, audio').forEach(media => {
      const elem = media as HTMLMediaElement;
      elem.controls = s.audioControls || false;
      
      Array.from(elem.textTracks).forEach(track => {
        if (track.kind === 'subtitles' || track.kind === 'captions') {
          track.mode = s.autoTranscription ? 'showing' : 'disabled';
        }
      });
    });

    // Alertas visuales
    if (s.visualAlerts) {
      document.querySelectorAll('audio').forEach(audio => {
        if (!audio.hasAttribute('data-visual-alert-handler')) {
          const handlePlay = () => {
            const alert = document.createElement('div');
            alert.className = 'audio-visual-alert';
            alert.setAttribute('role', 'status');
            alert.setAttribute('aria-live', 'polite');
            document.body.appendChild(alert);
            setTimeout(() => alert.remove(), 2000);
          };
          audio.addEventListener('play', handlePlay);
          audio.setAttribute('data-visual-alert-handler', 'true');
        }
      });
    } else {
      document.querySelectorAll('audio[data-visual-alert-handler]').forEach(audio => {
        removeEventListeners(audio, ['play']);
        audio.removeAttribute('data-visual-alert-handler');
      });
    }

    // Control por voz
    if (s.voiceControl && ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      body.setAttribute('data-voice-control', 'true');
    } else {
      body.removeAttribute('data-voice-control');
    }

  } catch (error) {
    console.warn('Error applying accessibility settings:', error);
  }
}

// Hook principal
export function useAccessibility() {
  const [settings, setSettings] = useState<AccessibilitySettings>(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : DEFAULTS;
    } catch {
      return DEFAULTS;
    }
  });

  // Aplicar configuraciones
  useEffect(() => {
    applySettingsToDOM(settings);
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    } catch (error) {
      console.warn('Error saving accessibility settings:', error);
    }
  }, [settings]);

  // Sincronización entre pestañas
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === STORAGE_KEY && e.newValue) {
        try {
          const newSettings = JSON.parse(e.newValue);
          setSettings(newSettings);
          applySettingsToDOM(newSettings);
        } catch (error) {
          console.warn('Error syncing accessibility settings:', error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);

  // Actualizar configuración individual
  const updateSetting = useCallback(<K extends keyof AccessibilitySettings>(
    key: K,
    value: AccessibilitySettings[K]
  ): void => {
    setSettings(prev => ({ ...prev, [key]: value }));
  }, []);

  // Restablecer configuraciones
  const resetSettings = useCallback((): void => {
    setSettings(DEFAULTS);
  }, []);

  return {
    settings,
    updateSetting,
    resetSettings
  };
}

export type AccessibilitySettings = {
  // Auditiva
  autoTranscription?: boolean;
  audioControls?: boolean;
  visualAlerts?: boolean;
  signLanguage?: boolean;

  // Visual
  textSize?: number; // 1..5
  fontType?: string;
  linkHighlight?: boolean;
  textSpacing?: number; // 1..5

  // Motriz
  keyboardNavigation?: boolean;
  largeButtons?: boolean;
  voiceControl?: boolean;
  autoScrollBlock?: boolean;
};

const STORAGE_KEY = 'accessibility-settings';

const DEFAULTS: AccessibilitySettings = {
  // Auditiva
  autoTranscription: false,
  audioControls: false,
  visualAlerts: false,
  signLanguage: false,

  // Visual
  textSize: 1,
  fontType: 'Arial',
  linkHighlight: false,
  textSpacing: 1,

  // Motriz
  keyboardNavigation: true,
  largeButtons: false,
  voiceControl: false,
  autoScrollBlock: false,
};

type EventListenerInfo = {
  type: string;
  handler: EventListener;
  element: HTMLElement | Document;
};

function removeEventListeners(element: HTMLElement | Document, events: string[]): void {
  const eventListeners: EventListenerInfo[] = [];

  const addToList = (type: string, handler: EventListener, elem: HTMLElement | Document): void => {
    eventListeners.push({ type, handler, element: elem });
  };

  const removeFromList = (type: string, handler: EventListener): void => {
    const index = eventListeners.findIndex(l => l.type === type && l.handler === handler);
    if (index > -1) {
      eventListeners.splice(index, 1);
    }
  };

  // Override addEventListener
  const originalAddEventListener = element.addEventListener;
  element.addEventListener = function(
    this: HTMLElement | Document,
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void {
    addToList(type, handler as EventListener, this);
    originalAddEventListener.call(this, type, handler, options);
  };

  // Override removeEventListener
  const originalRemoveEventListener = element.removeEventListener;
  element.removeEventListener = function(
    this: HTMLElement | Document,
    type: string,
    handler: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void {
    removeFromList(type, handler as EventListener);
    originalRemoveEventListener.call(this, type, handler, options);
  };

  // Remove specified event listeners
  events.forEach(event => {
    const listenersToRemove = eventListeners.filter(l => l.type === event && l.element === element);
    listenersToRemove.forEach(l => {
      l.element.removeEventListener(l.type, l.handler);
    });
  });
};

function applySettingsToDOM(s: AccessibilitySettings): void {
  try {
    const docEl = document.documentElement;
    const body = document.body;

    // Remover clases existentes
    const classesToRemove = [
      'accessibility-enabled',
      'highlight-links',
      'keyboard-nav',
      'large-buttons',
      'auto-scroll-block',
      'link-highlight'
    ];
    body.classList.remove(...classesToRemove);

    // Aplicar clase base de accesibilidad si hay alguna configuración activa
    const hasActiveSettings = Object.values(s).some(value => 
      value !== false && value !== 1 && value !== 'Arial' && value != null
    );
    if (hasActiveSettings) {
      body.classList.add('accessibility-enabled');
    }
    
    // Tamaño de texto
    const textSize = Math.max(1, Math.min(5, s.textSize ?? 1));
    const textSizeScale = 1 + (textSize - 1) * 0.2; // Escala de 1.0 a 1.8
    docEl.style.setProperty('--text-size-scale', String(textSizeScale));

    // Tipo de fuente
    if (s.fontType && s.fontType !== 'Arial') {
      body.style.setProperty('font-family', s.fontType + ', system-ui, sans-serif');
    } else {
      body.style.removeProperty('font-family');
    }

    // Espaciado de texto
    const textSpacing = Math.max(1, Math.min(5, s.textSpacing ?? 1));
    if (textSpacing > 1) {
      const letterSpacing = (textSpacing - 1) * 0.05;
      const lineHeight = 1.5 + (textSpacing - 1) * 0.25;
      body.style.setProperty('--text-letter-spacing', `${letterSpacing}em`);
      body.style.setProperty('--text-line-height', String(lineHeight));
    } else {
      body.style.removeProperty('--text-letter-spacing');
      body.style.removeProperty('--text-line-height');
    }

    // Enlaces resaltados
    if (s.linkHighlight) {
      body.classList.add('highlight-links');
      document.querySelectorAll('a').forEach(link => {
        if (!link.classList.contains('no-highlight')) {
          link.dataset.highlighted = 'true';
        }
      });
    } else {
      body.classList.remove('highlight-links');
      document.querySelectorAll('a[data-highlighted]').forEach(link => {
        delete link.dataset.highlighted;
      });
    }

    // Navegación por teclado
    if (s.keyboardNavigation) {
      body.classList.add('keyboard-nav');
      if (!document.getElementById('keyboard-nav-style')) {
        const style = document.createElement('style');
        style.id = 'keyboard-nav-style';
        style.textContent = `
          .keyboard-nav *:focus {
            outline: 3px solid #2563eb !important;
            outline-offset: 2px !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3) !important;
          }
        `;
        document.head.appendChild(style);
      }
    } else {
      body.classList.remove('keyboard-nav');
      document.getElementById('keyboard-nav-style')?.remove();
    }

    // Botones grandes
    const buttonSelector = 'button, .btn, input[type="button"], input[type="submit"]';
    if (s.largeButtons) {
      body.classList.add('large-buttons');
      document.querySelectorAll(buttonSelector).forEach(button => {
        (button as HTMLElement).dataset.originalSize = 'true';
      });
    } else {
      body.classList.remove('large-buttons');
      document.querySelectorAll(`${buttonSelector}[data-original-size]`).forEach(button => {
        delete (button as HTMLElement).dataset.originalSize;
      });
    }

    // Control de scroll y animaciones
    if (s.autoScrollBlock) {
      body.classList.add('auto-scroll-block');
      docEl.style.scrollBehavior = 'auto';
      document.getAnimations().forEach(animation => {
        if (!animation.finished) animation.pause();
      });
    } else {
      body.classList.remove('auto-scroll-block');
      docEl.style.removeProperty('scroll-behavior');
      document.getAnimations().forEach(animation => {
        if (animation.playState === 'paused') animation.play();
      });
    }

    // Control de audio y transcripciones
    document.querySelectorAll('video, audio').forEach(media => {
      const elem = media as HTMLMediaElement;
      
      // Controles de audio
      elem.controls = !!s.audioControls;
      
      // Transcripciones
      const tracks = elem.textTracks;
      for (let i = 0; i < tracks.length; i++) {
        if (tracks[i].kind === 'subtitles' || tracks[i].kind === 'captions') {
          tracks[i].mode = s.autoTranscription ? 'showing' : 'disabled';
        }
      }
    });

    // Alertas visuales para audio
    if (s.visualAlerts) {
      document.querySelectorAll('audio').forEach(audio => {
        if (!audio.dataset.visualAlertHandlerAdded) {
          audio.addEventListener('play', () => {
            const alert = document.createElement('div');
            alert.className = 'audio-visual-alert';
            alert.setAttribute('role', 'status');
            alert.setAttribute('aria-live', 'polite');
            document.body.appendChild(alert);
            setTimeout(() => alert.remove(), 2000);
          });
          audio.dataset.visualAlertHandlerAdded = 'true';
        }
      });
    }

    // Lenguaje de señas
    if (s.signLanguage) {
      document.querySelectorAll('video').forEach(video => {
        const tracks = video.textTracks;
        for (let i = 0; i < tracks.length; i++) {
          if (tracks[i].kind === 'sign') {
            tracks[i].mode = 'showing';
          }
        }
      });
    }

  } catch (error) {
    console.warn('Error applying accessibility settings:', error);
  }
  } catch (e) {
    // silent
    // In SSR or testing this may fail; ignore
  }
}

export function useAccessibility() {
  const [settings, setSettings] = useState<AccessibilitySettings>(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : DEFAULTS;
    } catch {
      return DEFAULTS;
    }
  });

  // Aplicar configuraciones al DOM y guardar en localStorage
  useEffect(() => {
    applySettingsToDOM(settings);
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    } catch (e) {
      console.warn('Error saving accessibility settings:', e);
    }
  }, [settings]);

  // Sincronizar cambios entre tabs/ventanas
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === STORAGE_KEY && e.newValue) {
        try {
          const newSettings = JSON.parse(e.newValue);
          setSettings(newSettings);
          applySettingsToDOM(newSettings);
        } catch (error) {
          console.warn('Error syncing accessibility settings:', error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);

  // Función para actualizar una configuración individual
  const updateSetting = useCallback(<K extends keyof AccessibilitySettings>(
    key: K,
    value: AccessibilitySettings[K]
  ) => {
    setSettings(prev => {
      const newSettings = { ...prev, [key]: value };
      return newSettings;
    });
  }, []);

  // Función para restablecer las configuraciones
  const resetSettings = useCallback(() => {
    setSettings(DEFAULTS);
  }, []);

  return {
    settings,
    updateSetting,
    resetSettings
  };
      if (e.key === FORM_KEY) {
        try {
          const form = e.newValue ? JSON.parse(e.newValue) : null;
          if (!form) return;
          // Merge visual fields from form into current settings
          setSettings((prev) => {
            const next = { ...prev } as AccessibilitySettings;
            const visualKeys: Array<keyof AccessibilitySettings> = [
              'darkMode',
              'highContrast',
              'textSize',
              'fontType',
              'linkHighlight',
              'textSpacing',
            ];
            visualKeys.forEach((k) => {
              if (form[k] !== undefined) next[k] = form[k];
            });
            return next;
          });
        } catch {
          // ignore
        }
      } else if (e.key === STORAGE_KEY) {
        try {
          const s = e.newValue ? JSON.parse(e.newValue) : null;
          if (s) setSettings((prev) => ({ ...prev, ...s }));
        } catch {
          // ignore
        }
      }
    };
    window.addEventListener('storage', onStorage);
    return () => window.removeEventListener('storage', onStorage);
  }, []);

  const updateSetting = useCallback((k: keyof AccessibilitySettings, v: any) => {
    setSettings((prev) => ({ ...prev, [k]: v }));
  }, []);

  const resetSettings = useCallback(() => {
    setSettings(DEFAULTS);
  }, []);

  return { settings, updateSetting, resetSettings } as const;
}

export default useAccessibility;
